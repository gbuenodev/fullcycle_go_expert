
 ‚ñê‚ñõ‚ñà‚ñà‚ñà‚ñú‚ñå   Claude Code v2.0.46
‚ñù‚ñú‚ñà‚ñà‚ñà‚ñà‚ñà‚ñõ‚ñò  Sonnet 4.5 ¬∑ Claude Pro
  ‚ñò‚ñò ‚ñù‚ñù    /Users/admin/FullCycle/fullcycle_go_expert/desafio04

> /clear 
  ‚éø ¬†(no content)

> Vamos come√ßar um projeto na pasta desafio04. Um frontend que ser√° escrito 
em REACT. Esse front ser√° muito simples: consiste em uma p√°gina simples que 
possui um formul√°rio onde o usu√°rio poder√° digitar o CEP. Ao faze-lo o site 
ir√° chamar o backend que ir√° consultar o clima correspondente na cidade do 
CEP. Antes de come√ßarmos, aqui v√£o algumas instru√ß√µes importantes. 1 - N√£o 
quero que voc√™ me forne√ßa c√≥digos prontos, a n√£o ser que eu te pe√ßa. 2 - 
Quero que voc√™ me guie no processo como um PM me dando tarefas para realizar
 e alcan√ßar o objetivo proposto. 3 - Vamos manter o c√≥digo simples. √â um 
exerc√≠cio simples para pr√°tica e constru√ß√£o de projeto. 4 - Ambos o front e 
o back rodar√£o no CloudRun.
Detalhes t√©cnicos: O front ser√° em React, somente uma p√°gina. O back ser√° em
 GO utilizando arquitetura Clean Architecture. Respostas poss√≠veis do 
back-end:
HTTP 200
BODY: {"temp_C": 28.5, "temp_F": 75, "temp_L": 102}

HTTP 422
Mensagem: "invalid zipcode"

HTTP 404
Mensagem: "can not find zipcode"

Vamos come√ßar pelo front. Depois detalharei mais o back. 

‚è∫ Perfeito! Vou atuar como PM e guiar voc√™ no desenvolvimento deste projeto.
   Entendi que vamos come√ßar pelo frontend em React.

  Deixe-me criar um plano de tarefas para o desenvolvimento do frontend:

‚è∫ Excelente! Criei um plano de tarefas para o desenvolvimento do frontend.
  Aqui est√° o roteiro:

  üìã Plano de Desenvolvimento - Frontend React

  Tarefa 1: Inicializar projeto React
  - Crie uma pasta frontend dentro de desafio04
  - Inicialize um projeto React (pode usar create-react-app, vite, ou o que
  preferir)
  - Fa√ßa a limpeza dos arquivos desnecess√°rios que v√™m no template

  Tarefa 2: Criar estrutura b√°sica da p√°gina
  - Defina a estrutura do componente principal
  - Prepare o layout b√°sico (t√≠tulo, container para o formul√°rio)

  Tarefa 3: Implementar formul√°rio de entrada de CEP
  - Campo de input para o CEP
  - Bot√£o de submit
  - Controle de estado do input

  Tarefa 4: Valida√ß√£o de CEP
  - Validar formato brasileiro (xxxxx-xxx ou xxxxxxxx)
  - Exibir mensagem se o formato estiver inv√°lido

  Tarefa 5: Servi√ßo de API
  - Criar fun√ß√£o para fazer a chamada HTTP ao backend
  - Configurar a URL do backend (use vari√°vel de ambiente)

  Tarefa 6-8: Exibi√ß√£o e Tratamento
  - Mostrar temperaturas (Celsius, Fahrenheit, Kelvin)
  - Tratar respostas 404 e 422
  - Adicionar loading durante a requisi√ß√£o

  Tarefa 9: Dockerfile
  - Preparar para deploy no CloudRun

  Tarefa 10: Testes
  - Validar funcionamento local

  ---
  Comece pela Tarefa 1! Me avise quando estiver pronta para eu passar os
  detalhes da pr√≥xima tarefa.

> Vamos come√ßar. Estou na tarefa 1. J√° inicializei o projeto com npm create 
vite@latest frontend.
Por favor, daqui para frente, forne√ßa mais detalhes nas tarefas. 

‚è∫ Perfeito! Vamos completar a Tarefa 1 com todos os detalhes.

  üìù Tarefa 1: Inicializar projeto React (Detalhes)

  Passos a seguir:

  1.1 - Instalar depend√™ncias
  cd frontend
  npm install

  1.2 - Testar se est√° funcionando
  npm run dev
  - Acesse no navegador e verifique se o template do Vite est√° rodando
  - Depois pare o servidor (Ctrl+C)

  1.3 - Limpar arquivos desnecess√°rios do template

  Remova os seguintes arquivos (n√£o vamos precisar):
  - src/App.css (vamos criar um CSS simples depois)
  - src/index.css (ou mantenha para reset b√°sico, sua escolha)
  - src/assets/* (todos os assets que vierem no template)
  - Todo conte√∫do de exemplo dentro de src/App.jsx ou src/App.tsx

  1.4 - Estrutura de pastas recomendada

  Crie a seguinte estrutura dentro de src/:
  src/
    ‚îú‚îÄ‚îÄ components/      (para componentes reutiliz√°veis)
    ‚îú‚îÄ‚îÄ services/        (para chamadas de API)
    ‚îú‚îÄ‚îÄ App.jsx          (componente principal)
    ‚îî‚îÄ‚îÄ main.jsx         (ponto de entrada)

  1.5 - Configurar vari√°vel de ambiente

  Crie um arquivo .env na raiz do projeto frontend:
  VITE_API_URL=http://localhost:8080
  (Ajuste a porta conforme seu backend quando estiver pronto)

  1.6 - Limpar o App.jsx

  Deixe o App.jsx apenas com uma estrutura b√°sica vazia:
  - Uma fun√ß√£o que retorna um div vazio ou com um "Hello World" simples
  - Sem imports de CSS por enquanto
  - Sem c√≥digo de exemplo do Vite

  ---
  ‚úÖ Crit√©rios de conclus√£o da Tarefa 1:
  - Projeto instalado e rodando
  - Arquivos desnecess√°rios removidos
  - Estrutura de pastas criada
  - App.jsx limpo e pronto para come√ßar

  Me avise quando concluir estes passos!

> Para acelerar o desenvolvimento, vamos usar algum framework react para 
estiliza√ß√£o.
Siga na tarefa 01. 
                                                                           
‚è∫¬†User answered Claude's questions:
  ‚éø ¬†¬∑ Qual framework de estiliza√ß√£o voc√™ prefere usar para este projeto? ‚Üí 
     Material-UI (MUI)


‚è∫ Excelente escolha! Material-UI √© perfeito para este projeto. Vamos
  adicionar √† Tarefa 1.

  üìù Tarefa 1 (continua√ß√£o): Adicionar Material-UI

  Passos adicionais:

  1.7 - Instalar Material-UI

  npm install @mui/material @emotion/react @emotion/styled

  O MUI usa Emotion para estiliza√ß√£o, por isso precisa desses pacotes.

  1.8 - Instalar √≠cones do Material (opcional, mas √∫til)

  npm install @mui/icons-material

  Vamos usar para √≠cones de loading, busca, etc.

  1.9 - Configurar tema b√°sico (opcional)

  Por enquanto, voc√™ pode usar o tema padr√£o do MUI. Se quiser customizar
  cores depois, podemos criar um tema personalizado. Para manter simples,
  vamos usar o padr√£o.

  1.10 - Testar instala√ß√£o do MUI

  No seu App.jsx limpo, fa√ßa um teste r√°pido importando um componente do
  MUI:

  import { Button } from '@mui/material';

  function App() {
    return (
      <div>
        <Button variant="contained">Teste MUI</Button>
      </div>
    );
  }

  export default App;

  Rode npm run dev e verifique se o bot√£o aparece estilizado.

  ---
  ‚úÖ Crit√©rios atualizados de conclus√£o da Tarefa 1:
  - Projeto instalado e rodando ‚úì
  - Arquivos desnecess√°rios removidos ‚úì
  - Estrutura de pastas criada ‚úì
  - App.jsx limpo ‚úì
  - Material-UI instalado e testado ‚Üê novo
  - .env configurado ‚úì

  Me avise quando tiver o MUI funcionando!

> Tudo funcionando 

‚è∫ Perfeito! ‚úÖ Tarefa 1 conclu√≠da.

  üìù Tarefa 2: Criar estrutura b√°sica da p√°gina principal

  Agora vamos estruturar o layout da aplica√ß√£o usando componentes do
  Material-UI.

  Passos a seguir:

  2.1 - Estruturar o App.jsx

  No seu App.jsx, crie a estrutura b√°sica da p√°gina:

  Componentes MUI que voc√™ vai usar:
  - Container - para centralizar e limitar a largura do conte√∫do
  - Box - para espa√ßamentos e layout flex√≠vel
  - Typography - para textos estilizados
  - Paper - para criar um card/painel elevado

  Estrutura sugerida:
  Container (maxWidth="sm")
    ‚îî‚îÄ‚îÄ Box (padding, display flex, dire√ß√£o coluna, centralizado)
        ‚îú‚îÄ‚îÄ Typography (t√≠tulo da aplica√ß√£o)
        ‚îú‚îÄ‚îÄ Paper (card principal onde ficar√° o formul√°rio)
        ‚îÇ   ‚îî‚îÄ‚îÄ Box (padding interno)
        ‚îÇ       ‚îî‚îÄ‚îÄ [aqui vir√° o formul√°rio na pr√≥xima tarefa]
        ‚îî‚îÄ‚îÄ [aqui vir√° a exibi√ß√£o de resultados]

  2.2 - Elementos que a p√°gina deve ter:

  1. T√≠tulo principal: algo como "Consulta de Clima por CEP"
  2. Card/Paper principal: onde ficar√° o formul√°rio (preparar o espa√ßo)
  3. Espa√ßamento adequado: use padding e margin com o Box do MUI
  4. Centraliza√ß√£o vertical: para ficar visualmente agrad√°vel

  2.3 - Dicas de estiliza√ß√£o:

  - Use sx prop do MUI para estilos inline (√© a forma moderna do MUI)
  - Defina um minHeight: '100vh' no container principal para ocupar a tela
  toda
  - Use display: 'flex', flexDirection: 'column', alignItems: 'center', 
  justifyContent: 'center'
  - Adicione um background color suave se quiser (opcional)

  2.4 - Imports necess√°rios:

  import { Container, Box, Typography, Paper } from '@mui/material';

  ---
  ‚úÖ Crit√©rios de conclus√£o da Tarefa 2:
  - App.jsx com estrutura de Container, Box e Paper
  - T√≠tulo da aplica√ß√£o vis√≠vel
  - Layout centralizado na tela
  - Card/Paper pronto para receber o formul√°rio
  - P√°gina visualmente limpa e organizada

  Importante: N√£o precisa adicionar o formul√°rio ainda, apenas prepare o
  "esqueleto" da p√°gina.

  Me avise quando estiver pronto!

> Um detalhe importante, estou usando typescript.
Me mostre um c√≥digo para o app.tsx para eu comparar com o que eu fiz. 

‚è∫ Ah, √≥timo! TypeScript √© uma excelente escolha. Vou te mostrar um exemplo
  de App.tsx para voc√™ comparar:

  import { Container, Box, Typography, Paper } from '@mui/material';

  function App() {
    return (
      <Container maxWidth="sm">
        <Box
          sx={{
            minHeight: '100vh',
            display: 'flex',
            flexDirection: 'column',
            justifyContent: 'center',
            alignItems: 'center',
            gap: 3,
            py: 4
          }}
        >
          <Typography 
            variant="h3" 
            component="h1" 
            gutterBottom
            sx={{ fontWeight: 'bold', color: 'primary.main' }}
          >
            Consulta de Clima por CEP
          </Typography>

          <Paper 
            elevation={3}
            sx={{ 
              width: '100%',
              p: 4
            }}
          >
            <Box>
              {/* Formul√°rio vir√° aqui na pr√≥xima tarefa */}
              <Typography variant="body2" color="text.secondary">
                Formul√°rio ser√° adicionado aqui...
              </Typography>
            </Box>
          </Paper>

          <Box sx={{ width: '100%' }}>
            {/* Resultados ser√£o exibidos aqui */}
          </Box>
        </Box>
      </Container>
    );
  }

  export default App;

  Pontos importantes deste c√≥digo:

  1. Container com maxWidth="sm" - limita a largura em telas grandes
  2. Box principal - centraliza verticalmente (100vh) e horizontalmente
  3. gap: 3 - espa√ßamento autom√°tico entre elementos filhos
  4. py: 4 - padding vertical
  5. Paper com elevation={3} - card com sombra
  6. p: 4 - padding interno do Paper
  7. Typography com variant - estilos sem√¢nticos do MUI

  Compare com o seu c√≥digo:
  - Estrutura similar?
  - Est√° usando as mesmas props sx?
  - Centralizou corretamente?

  Se quiser melhorar ainda mais, pode adicionar um background color no Box
  principal:
  sx={{
    minHeight: '100vh',
    backgroundColor: '#f5f5f5', // ou 'background.default'
    // ... resto das props
  }}

  Est√° parecido com o que voc√™ fez?

> Sim, est√° ok. Vamos seguir 

‚è∫ √ìtimo! ‚úÖ Tarefa 2 conclu√≠da.

  üìù Tarefa 3: Implementar formul√°rio de entrada de CEP

  Agora vamos criar o formul√°rio dentro do Paper que preparamos.

  Passos a seguir:

  3.1 - Estados necess√°rios

  Voc√™ vai precisar de estados para controlar:
  1. cep - string que armazena o valor digitado pelo usu√°rio
  2. loading - boolean para controlar estado de carregamento (preparando
  para tarefa futura)
  3. error - string ou null para mensagens de erro
  4. result - objeto ou null para armazenar o resultado da API

  Imports do React:
  import { useState } from 'react';

  3.2 - Criar os estados

  const [cep, setCep] = useState<string>('');
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [result, setResult] = useState<{ temp_C: number; temp_F: number;
  temp_K: number } | null>(null);

  3.3 - Fun√ß√£o de submit

  Crie uma fun√ß√£o handleSubmit que:
  - Previne o comportamento padr√£o do form
  - Por enquanto, apenas fa√ßa um console.log(cep)
  - Vamos implementar a l√≥gica de API depois

  Assinatura:
  const handleSubmit = (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    console.log('CEP digitado:', cep);
    // L√≥gica vir√° nas pr√≥ximas tarefas
  };

  3.4 - Componentes do formul√°rio

  Dentro do Paper, substitua o texto placeholder por:

  Componentes MUI a usar:
  - TextField - input do CEP
  - Button - bot√£o de buscar
  - Box - para layout (se necess√°rio)

  Props importantes do TextField:
  - label: "CEP"
  - value: state cep
  - onChange: atualizar o state
  - fullWidth: ocupa toda largura
  - placeholder: "00000-000"
  - variant: "outlined" (padr√£o do MUI)
  - type: "text"

  Props importantes do Button:
  - variant: "contained"
  - type: "submit"
  - fullWidth: true (ou false, sua escolha)
  - size: "large"

  3.5 - Estrutura do formul√°rio

  <form onSubmit={handleSubmit}>
    <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
      {/* TextField aqui */}
      {/* Button aqui */}
    </Box>
  </form>

  3.6 - Imports necess√°rios

  Adicione ao import do MUI:
  import { Container, Box, Typography, Paper, TextField, Button } from
  '@mui/material';

  ---
  ‚úÖ Crit√©rios de conclus√£o da Tarefa 3:
  - Estados criados (cep, loading, error, result)
  - TextField funcionando e controlado pelo state
  - Button de submit presente
  - Fun√ß√£o handleSubmit criada (mesmo que s√≥ fa√ßa console.log)
  - Form com tag <form> e evento onSubmit
  - Input aceita digita√ß√£o e mostra o valor

  Teste:
  - Digite um CEP e clique no bot√£o
  - Verifique se aparece no console do navegador

  Me avise quando estiver pronto!

> Isso ser√° criado na pasta components como um componente pr√≥prio certo? 

‚è∫ Boa pergunta! Vamos analisar:

  Para este projeto simples, recomendo manter tudo no App.tsx

  Por qu√™?
  1. √â apenas uma p√°gina √∫nica
  2. Os estados (cep, loading, error, result) precisam estar no componente
  pai para compartilhar dados entre o formul√°rio e a √°rea de resultados
  3. Criar componentes separados aqui exigiria props drilling ou context, o
  que complica desnecessariamente
  4. Voc√™ quer manter o c√≥digo simples - isso √© KISS (Keep It Simple,
  Stupid)

  Quando faria sentido componentizar?
  - Se tiv√©ssemos m√∫ltiplas p√°ginas
  - Se o formul√°rio fosse reutilizado em v√°rios lugares
  - Se o projeto fosse crescer significativamente

  Estrutura recomendada:
  src/
    ‚îú‚îÄ‚îÄ services/        ‚Üê aqui sim vamos usar (para API)
    ‚îú‚îÄ‚îÄ components/      ‚Üê pode deixar vazio por enquanto
    ‚îú‚îÄ‚îÄ App.tsx          ‚Üê formul√°rio + resultados tudo aqui
    ‚îî‚îÄ‚îÄ main.tsx

  Alternativa (se voc√™ quiser praticar componentiza√ß√£o):
  Poder√≠amos criar componentes como WeatherForm.tsx e WeatherResult.tsx, mas
   passar√≠amos muitas props entre eles. Para aprendizado est√° OK, mas
  adiciona complexidade.

  ---
  Qual abordagem prefere?
  A. Manter tudo no App.tsx (recomendado)
  B. Criar componentes separados (para praticar)

  O que voc√™ decide?

> B 

‚è∫ Perfeito! Vamos componentizar ent√£o. Isso vai deixar o c√≥digo mais
  organizado e voc√™ pratica arquitetura React.

  üìù Tarefa 3 (Atualizada): Criar componente WeatherForm

  Nova abordagem com componentes:

  Arquitetura:
  App.tsx (pai)
    ‚îú‚îÄ‚îÄ gerencia estados: loading, error, result
    ‚îú‚îÄ‚îÄ fun√ß√£o handleWeatherSearch (chama API)
    ‚îî‚îÄ‚îÄ renderiza:
        ‚îú‚îÄ‚îÄ WeatherForm (filho)
        ‚îÇ   ‚îî‚îÄ‚îÄ recebe: onSubmit, loading (props)
        ‚îî‚îÄ‚îÄ WeatherResult (filho - tarefa futura)
            ‚îî‚îÄ‚îÄ recebe: result, error (props)

  ---
  Passos atualizados:

  3.1 - Criar o componente WeatherForm

  Crie o arquivo: src/components/WeatherForm.tsx

  Responsabilidades deste componente:
  - Gerenciar apenas o estado local do input CEP
  - Renderizar TextField e Button
  - Validar e emitir o CEP para o componente pai

  Props que o componente deve receber:
  interface WeatherFormProps {
    onSubmit: (cep: string) => void;
    loading: boolean;
  }

  3.2 - Estrutura do WeatherForm.tsx

  O componente deve ter:
  1. Interface de Props
  2. Estado local: cep (string)
  3. Fun√ß√£o handleSubmit que:
    - Previne default
    - Chama props.onSubmit(cep) passando o CEP para o pai
  4. Form com TextField e Button
  5. Button desabilitado quando loading === true

  3.3 - Imports necess√°rios no WeatherForm:
  import { useState } from 'react';
  import { Box, TextField, Button } from '@mui/material';

  3.4 - Atualizar o App.tsx

  No App.tsx, voc√™ vai:
  1. Criar os estados: loading, error, result
  2. Criar fun√ß√£o handleWeatherSearch:
  const handleWeatherSearch = (cep: string) => {
    console.log('CEP recebido do form:', cep);
    // API call vir√° depois
  };
  3. Importar e usar o componente <WeatherForm />
  4. Passar as props corretas

  3.5 - Props do WeatherForm no App.tsx:
  <WeatherForm
    onSubmit={handleWeatherSearch}
    loading={loading}
  />

  ---
  ‚úÖ Crit√©rios de conclus√£o da Tarefa 3:
  - Arquivo WeatherForm.tsx criado em src/components/
  - Interface WeatherFormProps definida
  - Estado local cep dentro do WeatherForm
  - TextField e Button funcionando
  - Button desabilitado quando loading=true
  - App.tsx com estados (loading, error, result)
  - App.tsx importa e usa WeatherForm
  - Console.log mostra CEP quando form √© submetido

  Quer que eu mostre o c√≥digo dos dois arquivos (WeatherForm.tsx e App.tsx 
  atualizado) para voc√™ comparar?

> N√£o vamos usar prop drilling, vamos usar react hooks 
  ‚éø ¬†Interrupted ¬∑ What should Claude do instead?

> N√£o vamos usar prop drilling, vamos usar react hooks + context api 

‚è∫ Excelente decis√£o! Context API + hooks √© uma abordagem muito mais
  profissional e escal√°vel. Vamos refazer a arquitetura.

  üìù Tarefa 3 (Atualizada): Implementar com Context API

  Nova arquitetura:

  src/
    ‚îú‚îÄ‚îÄ context/
    ‚îÇ   ‚îî‚îÄ‚îÄ WeatherContext.tsx    (Context + Provider)
    ‚îú‚îÄ‚îÄ hooks/
    ‚îÇ   ‚îî‚îÄ‚îÄ useWeather.ts          (Custom hook)
    ‚îú‚îÄ‚îÄ components/
    ‚îÇ   ‚îú‚îÄ‚îÄ WeatherForm.tsx        (usa useWeather)
    ‚îÇ   ‚îî‚îÄ‚îÄ WeatherResult.tsx      (usa useWeather - tarefa futura)
    ‚îú‚îÄ‚îÄ services/
    ‚îÇ   ‚îî‚îÄ‚îÄ weatherService.ts      (chamadas API - tarefa futura)
    ‚îú‚îÄ‚îÄ App.tsx                    (s√≥ renderiza componentes)
    ‚îî‚îÄ‚îÄ main.tsx

  ---
  Passos atualizados:

  3.1 - Criar as pastas
  src/context/
  src/hooks/

  3.2 - Criar o WeatherContext.tsx

  Arquivo: src/context/WeatherContext.tsx

  Responsabilidades:
  - Criar o Context
  - Definir tipos/interfaces
  - Provider com todos os estados
  - Fun√ß√£o para buscar clima (por enquanto mock)

  O que deve ter:
  // Tipos
  interface WeatherData {
    temp_C: number;
    temp_F: number;
    temp_K: number;
  }

  interface WeatherContextType {
    loading: boolean;
    error: string | null;
    result: WeatherData | null;
    searchWeather: (cep: string) => void;
  }

  // Context
  const WeatherContext = createContext<WeatherContextType |
  undefined>(undefined);

  // Provider Component
  export const WeatherProvider: React.FC<{ children: React.ReactNode }> = ({
   children }) => {
    // estados aqui
    // fun√ß√£o searchWeather aqui (por enquanto s√≥ console.log)
    // return <WeatherContext.Provider value={{ ... }}>
  }

  3.3 - Criar o hook customizado

  Arquivo: src/hooks/useWeather.ts

  Responsabilidade:
  - Consumir o WeatherContext
  - Validar se est√° sendo usado dentro do Provider
  - Retornar os valores do context

  Estrutura:
  export const useWeather = () => {
    const context = useContext(WeatherContext);

    if (!context) {
      throw new Error('useWeather must be used within WeatherProvider');
    }

    return context;
  };

  3.4 - Criar WeatherForm.tsx

  Arquivo: src/components/WeatherForm.tsx

  Usa o hook:
  const { loading, searchWeather } = useWeather();

  Caracter√≠sticas:
  - Estado local apenas para o input (cep)
  - Chama searchWeather(cep) no submit
  - Button desabilitado quando loading

  3.5 - Atualizar App.tsx

  Envolver tudo com o Provider:
  import { WeatherProvider } from './context/WeatherContext';
  import WeatherForm from './components/WeatherForm';

  function App() {
    return (
      <WeatherProvider>
        <Container maxWidth="sm">
          {/* estrutura do layout */}
          <WeatherForm />
          {/* resultados vir√£o depois */}
        </Container>
      </WeatherProvider>
    );
  }

  3.6 - Atualizar main.tsx (se necess√°rio)

  Certifique-se que o Provider est√° no lugar certo da √°rvore.

  ---
  ‚úÖ Crit√©rios de conclus√£o da Tarefa 3:
  - Pastas context/ e hooks/ criadas
  - WeatherContext.tsx com Context + Provider
  - useWeather.ts com custom hook
  - WeatherForm.tsx usando o hook
  - App.tsx envolto com WeatherProvider
  - Console.log mostra CEP quando form submetido
  - Sem prop drilling, tudo via Context

  Quer que eu mostre o c√≥digo completo de cada arquivo para voc√™ comparar?



